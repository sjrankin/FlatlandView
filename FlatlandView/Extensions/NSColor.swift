//
//  NSColor.swift
//  Flatland
//
//  Created by Stuart Rankin on 7/30/20.
//  Copyright Â© 2020 Stuart Rankin. All rights reserved.
//

import Foundation
import AppKit
import CoreGraphics

// MARK: - NSColor extensions.

extension NSColor
{
    /// Create an NSColor using a hex string generated by `Hex` using the format `#rrggbbaa` or
    /// `#rrggbb`.
    /// - Note: The format of `HexString` is `#rrggbbaa` where `rr`, `gg`, `bb`, and `aa`
    ///         are all hexidecimal values. Badly formatted strings will result in nil
    ///         being returned.
    /// - Parameter HexString: The string to use as the source value for the color.
    /// - Parameter RGBA: Determines the expected order of the channels. If this parameter is `true`, channels
    ///                   are expected in RGBA order. If this parameter is false, channels are expected in
    ///                   ARGB order.
    /// - Returns: Nil on error, NSColor on success.
    convenience init?(HexString: String, RGBA: Bool = true)
    {
        if RGBA
        {
            if let (Red, Green, Blue, Alpha) = Utility.ColorChannelsFromRGBA(HexString)
            {
                self.init(red: Red, green: Green, blue: Blue, alpha: Alpha)
            }
            else
            {
                return nil
            }
        }
        else
        {
            if let (Red, Green, Blue, Alpha) = Utility.ColorChannelsFromARGB(HexString)
            {
                self.init(red: Red, green: Green, blue: Blue, alpha: Alpha)
            }
            else
            {
                return nil
            }
        }
    }
    
    /// Create an NSColor using a value interpreted as a hex color value. See also `NSColor(RGB:)`.
    /// - Parameter RGBA: Value to convert to a color. Value is assumed to be in the format of `rrggbbaa`.
    /// - Returns: `NSColor` based on the passed value.
    convenience init(RGBA: UInt)
    {
        var Red: UInt = 0
        var Green: UInt = 0
        var Blue: UInt = 0
        var Alpha: UInt = 0xff
        
        Red = RGBA & 0xff000000
        Red = Red >> 24
        Green = RGBA & 0x00ff0000
        Green = Green >> 16
        Blue = RGBA & 0x0000ff00
        Blue = Blue >> 8
        Alpha = RGBA & 0x000000ff
        Alpha = Alpha >> 0
        
        let FinalRed: CGFloat = CGFloat(Red) / 255.0
        let FinalGreen: CGFloat = CGFloat(Green) / 255.0
        let FinalBlue: CGFloat = CGFloat(Blue) / 255.0
        let FinalAlpha: CGFloat = CGFloat(Alpha) / 255.0
        self.init(red: FinalRed, green: FinalGreen, blue: FinalBlue, alpha: FinalAlpha)
    }
    
    /// Create an NSColor using a value interpreted as a hex color value. The value to convert is assumed
    /// to be an RGB value. See also `NSColor(RGBA:)`.
    /// - Warning: If the value of `RGB` is greater than `0xffffff` a fatal error will be thrown.
    /// - Parameter RGB: Value to convert to a color in the format `rrggbb`. Alpha is assigned 1.0.
    /// - Returns: `NSColor` base on the passed value.
    convenience init(RGB: Int)
    {
        if RGB > 0xffffff
        {
            Debug.FatalError("RGB value of \(RGB) is too big to convert to a color.")
        }
        
        var Red = RGB & 0xff0000
        Red = Red >> 16
        var Green = RGB & 0x00ff00
        Green = Green >> 8
        let Blue = RGB & 0x0000ff >> 0
        
        let FinalRed: CGFloat = CGFloat(Red) / 255.0
        let FinalGreen: CGFloat = CGFloat(Green) / 255.0
        let FinalBlue: CGFloat = CGFloat(Blue) / 255.0
        self.init(red: FinalRed, green: FinalGreen, blue: FinalBlue, alpha: 1.0)
    }
    
    /// Creates a color from the passed channel value.
    /// - Parameter Value: The channel value to use to populate the new color. This value must be
    ///                    a normal (0.0 to 1.0).
    /// - Parameter Alpha: The alpha value to use for the color. Defaults to `1.0`. When using the
    ///                    alpha channel of a color, pass it to this parameter, not `Value`. For
    ///                    `Value` use `1.0` instead.
    /// - Parameter Channel: The source channel for `Value`.
    static func UnitColor(_ Value: CGFloat, Alpha: CGFloat = 1.0, Channel: PickerColorChannels) -> NSColor
    {
        var Final: NSColor = NSColor()
        
        switch Channel
        {
            case .Red, .Green, .Blue:
                Final = NSColor(calibratedRed: Value, green: Value, blue: Value, alpha: Alpha)
                
            case .Hue:
                Final = NSColor(calibratedHue: Value, saturation: 0.5, brightness: 1.0, alpha: Alpha)
                
            case .Saturation:
                Final = NSColor(calibratedHue: Value, saturation: Value, brightness: 1.0, alpha: Alpha)
                
            case .Brightness:
                Final = NSColor(calibratedHue: Value, saturation: Value, brightness: Value, alpha: Alpha)
                
            case .Cyan:
                let (R, G, B) = CMYKtoRGB(Cyan: Value, Magenta: 0.0, Yellow: 0.0, Black: 0.0)
                Final = NSColor(calibratedRed: R, green: G, blue: B, alpha: Alpha)
                
            case .Magenta:
                let (R, G, B) = CMYKtoRGB(Cyan: 0.0, Magenta: Value, Yellow: 0.0, Black: 0.0)
                Final = NSColor(calibratedRed: R, green: G, blue: B, alpha: Alpha)
                
            case .Yellow:
                let (R, G, B) = CMYKtoRGB(Cyan: 0.0, Magenta: 0.0, Yellow: Value, Black: 0.0)
                Final = NSColor(calibratedRed: R, green: G, blue: B, alpha: Alpha)
                
            case .Black:
                let (R, G, B) = CMYKtoRGB(Cyan: 0.0, Magenta: 0.0, Yellow: 0.0, Black: Value)
                Final = NSColor(calibratedRed: R, green: G, blue: B, alpha: Alpha)
                
            case .Alpha:
                Final = NSColor(calibratedRed: Value, green: Value, blue: Value, alpha: Alpha)
        }
        
        return Final.InRGB
    }
    
    /// Returns an interpolated color between the two passed colors.
    /// - Parameter Color1: First color.
    /// - Parameter Color2: Second color.
    /// - Parameter Distance: How far the interpolated color is between `Color1` and `Color2`. This function
    ///                       expects this value to be normalized. If it isn't, the value is clamped to 0.0
    ///                       to 1.0.
    /// - Returns: Interpolated color between the two passed color.
    public static func Interpolate(_ Color1: NSColor, _ Color2: NSColor, Distance: Double) -> NSColor
    {
        var Dist = CGFloat(Distance)
        Dist = Dist < 0.0 ? 0.0 : Dist
        Dist = Dist > 1.0 ? 1.0 : Dist
        let (H1, S1, L1) = Color1.HSL
        let (H2, S2, L2) = Color2.HSL
        let HDelta = abs(H1 - H2)
        let HPercent = HDelta * Dist
        let SDelta = abs(S1 - S2)
        let SPercent = SDelta * Dist
        let LDelta = abs(L1 - L2)
        let LPercent = LDelta * Dist
        let FinalH = min(H1, H2) + HPercent
        let FinalS = min(S1, S2) + SPercent
        let FinalL = min(L1, L2) + LPercent
        return NSColor(calibratedHue: FinalH, saturation: FinalS, brightness: FinalL, alpha: 1.0)
    }
    
    /// Returns an interpolated color between the instance color and the passed color.
    /// - Parameter Other: The other color to use to interpolate a new color.
    /// - Parameter Distance: How far the interpolated color is between the instance color and `Other`.
    /// - Returns: Interpolated color between the instance color and the other color.
    public func Interpolate(_ Other: NSColor, Distance: Double) -> NSColor
    {
        return NSColor.Interpolate(self, Other, Distance: Distance)
    }
    
    /// Returns the color as a color guaranteed to be in RGB colorspace.
    var InRGB: NSColor
    {
        get
        {
            let CColor = CIColor(color: self)!
            return NSColor(calibratedRed: CColor.red, green: CColor.green, blue: CColor.blue, alpha: CColor.alpha)
        }
    }
    
    /// Convert the instance color to CMYK channels.
    /// - Note: No color profiles are used - just the naive algorithm.
    /// - Returns: Tuple with cyan, magenta, yellow, and black channels, each mutliplied by 100.0.
    func ToCMYK() -> (Cyan: CGFloat, Magenta: CGFloat, Yellow: CGFloat, Black: CGFloat)
    {
        let RGB = self.InRGB
        var Red: CGFloat = 0.0
        var Green: CGFloat = 0.0
        var Blue: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        RGB.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
        let K = 1.0 - max(Red, Green, Blue)
        if K == 1.0
        {
            return (0.0, 0.0, 0.0, 100.0)
        }
        let C = (1.0 - Red - K) / (1.0 - K)
        let M = (1.0 - Green - K) / (1.0 - K)
        let Y = (1.0 - Blue - K) / (1.0 - K)
        return (C * 100.0, M * 100.0, Y * 100.0, K * 100.0)
    }
    
    /// Convert the passed CMYK channels to an equivalent set of RGB channels.
    /// - Note: Color profiles are not used in the conversion process.
    /// - Parameter Cyan: The cyan channel value.
    /// - Parameter Magenta: The magenta channel value.
    /// - Parameter Yellow: The yellow channel value.
    /// - Parameter Black: The black channel value.
    /// - Returns: Tuple with red, green, and blue channel values.
    public static func CMYKtoRGB(Cyan: CGFloat, Magenta: CGFloat, Yellow: CGFloat, Black: CGFloat) -> (Red: CGFloat, Green: CGFloat, Blue: CGFloat)
    {
        let R = (1.0 - Cyan) * (1.0 - Black)
        let G = (1.0 - Magenta) * (1.0 - Black)
        let B = (1.0 - Yellow) * (1.0 - Black)
        return (R, G, B)
    }
    
    /// Returns the value of the color as a hex string. The string has the prefix
    /// `#` and is in RGBA order.
    /// - Note: This property converts all colors to sRGB prior to conversion to a hex string.
    var Hex: String
    {
        get
        {
            let Working = self.usingColorSpace(.sRGB)
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            Working!.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let IRed = Int(Red * 255.0)
            let SRed = String(format: "%02x", IRed)
            let IGreen = Int(Green * 255.0)
            let SGreen = String(format: "%02x", IGreen)
            let IBlue = Int(Blue * 255.0)
            let SBlue = String(format: "%02x", IBlue)
            let IAlpha = Int(Alpha * 255.0)
            let SAlpha = String(format: "%02x", IAlpha)
            let Final = "#" + SRed + SGreen + SBlue + SAlpha
            return Final
        }
    }
    
    /// Return a color based on the instance color but with the hue inverted (eg, `1.0 - self.Hue`).
    /// - Returns: Color based on the instance color but with an inverted hue.
    var InvertedHue: NSColor
    {
        let (H, S, B) = self.HSB
        let NewH = 1.0 - H
        return NSColor(calibratedHue: NewH, saturation: S, brightness: B, alpha: self.Alpha)
    }
    
    /// Returns the alpha value of the instance color.
    var Alpha: CGFloat
    {
        var Red: CGFloat = 0.0
        var Green: CGFloat = 0.0
        var Blue: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
        return Alpha
    }
    
    /// Return a darkened version of the instance color.
    /// - Parameter By: The percent to darken the color. Multiplies this value by the brightness value of
    ///                 the instance color. If the caller ignores the context and passes a value greater than
    ///                 `1.0`, this function will lighten the color. Negative values are converted to positive
    ///                 values.
    /// - Returns: New color with the brightness channel modified as described in the `By` section.
    func Darker(By: CGFloat = 0.5) -> NSColor
    {
        let FinalBy = abs(By)
        let (H, S, B) = self.HSB
        let A = self.Alpha
        return NSColor(calibratedHue: H, saturation: S, brightness: B * FinalBy, alpha: A)
    }
    
    /// Returns the YUV equivalent of the instance color, in Y, U, V order.
    /// - See
    ///   - [YUV](https://en.wikipedia.org/wiki/YUV)
    ///   - [FourCC YUV to RGB Conversion](http://www.fourcc.org/fccyvrgb.php)
    var YUV: (Y: CGFloat, U: CGFloat, V: CGFloat)
    {
        get
        {
            let Wr: CGFloat = 0.299
            let Wg: CGFloat = 0.587
            let Wb: CGFloat = 0.114
            let Umax: CGFloat = 0.436
            let Vmax: CGFloat = 0.615
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let Y = (Wr * Red) + (Wg * Green) + (Wb * Blue)
            let U = Umax * ((Blue - Y) / (1.0 - Wb))
            let V = Vmax * ((Red - Y) / (1.0 - Wr))
            return (Y, U, V)
        }
    }
    
    /// Returns the CMYK equivalent of the instance color, in C, M, Y, K order.
    var CMYK: (C: CGFloat, Y: CGFloat, M: CGFloat, K: CGFloat)
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let K: CGFloat = 1.0 - max(Red, max(Green, Blue))
            var C: CGFloat = 0.0
            var M: CGFloat = 0.0
            var Y: CGFloat = 0.0
            if K == 1.0
            {
                C = 1.0
            }
            else
            {
                C = abs((1.0 - Red - K) / (1.0 - K))
            }
            if K == 1.0
            {
                M = 1.0
            }
            else
            {
                M = abs((1.0 - Green - K) / (1.0 - K))
            }
            if K == 1.0
            {
                Y = 1.0
            }
            else
            {
                Y = abs((1.0 - Blue - K) / (1.0 - K))
            }
            return (C, M, Y, K)
        }
    }
    
    /// Returns the hue, saturation, and brightness channels. Convenience property for calling
    /// getHue on the color.
    /// - Note: If the instance color cannot be converted to the SRGB colorspace, all returned components
    ///         are set to `0.0`.
    var HSB: (H: CGFloat, S: CGFloat, B: CGFloat)
    {
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        if let ScratchColor = self.usingColorSpace(.sRGB)
        {
            ScratchColor.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
            return (H: Hue, S: Saturation, B: Brightness)
        }
        else
        {
            return (H: 0.0, S: 0.0, B: 0.0)
        }
    }
    
    /// Returns the CIE LAB equivalent of the instance color, in L, A, B order.
    /// - Note: See (Color math and programming code examples)[http://www.easyrgb.com/en/math.php]
    var LAB: (L: CGFloat, A: CGFloat, B: CGFloat)
    {
        get
        {
            let (X, Y, Z) = self.XYZ
            var Xr = X / 111.144                //X referent is X10 incandescent/tungsten
            var Yr = Y / 100.0                  //Y referent is X10 incandescent/tungsten
            var Zr = Z / 35.2                   //Z referent is X10 incandescent/tungsten
            if Xr > 0.008856
            {
                Xr = pow(Xr, (1.0 / 3.0))
            }
            else
            {
                Xr = (7.787 * Xr) + (16.0 / 116.0)
            }
            if Yr > 0.008856
            {
                Yr = pow(Yr, (1.0 / 3.0))
            }
            else
            {
                Yr = (7.787 * Yr) + (16.0 / 116.0)
            }
            if Zr > 0.008856
            {
                Zr = pow(Zr, (1.0 / 3.0))
            }
            else
            {
                Zr = (7.787 * Zr) + (16.0 / 116.0)
            }
            let L = (Xr * 116.0) - 16.0
            let A = 500.0 * (Xr - Yr)
            let B = 200.0 * (Yr - Zr)
            return (L, A, B)
        }
    }
    
    /// Returns the XYZ equivalent of the instance color, in X, Y, Z order.
    /// - Note: See (Color math and programming code examples)[http://www.easyrgb.com/en/math.php]
    var XYZ: (X: CGFloat, Y: CGFloat, Z: CGFloat)
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            if Red > 0.04045
            {
                Red = pow(((Red + 0.055) / 1.055), 2.4)
            }
            else
            {
                Red = Red / 12.92
            }
            if Green > 0.04045
            {
                Green = pow(((Green + 0.055) / 1.055), 2.4)
            }
            else
            {
                Green = Green / 12.92
            }
            if Blue > 0.04045
            {
                Blue = pow(((Blue + 0.055) / 1.055), 2.4)
            }
            else
            {
                Blue = Blue / 12.92
            }
            Red = Red * 100.0
            Green = Green * 100.0
            Blue = Blue * 100.0
            let X = (Red * 0.4124) + (Green * 0.3576) * (Blue * 0.1805)
            let Y = (Red * 0.2126) + (Green * 0.7152) * (Blue * 0.0722)
            let Z = (Red * 0.0193) + (Green * 0.1192) * (Blue * 0.9505)
            return (X, Y, Z)
        }
    }
    
    /// Returns the HSL equivalent of the instance color, in H, S, L order.
    /// - Note: See (Color math and programming code examples)[http://www.easyrgb.com/en/math.php]
    var HSL: (H: CGFloat, S: CGFloat, L: CGFloat)
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let Min = min(Red, Green, Blue)
            let Max = max(Red, Green, Blue)
            let Delta = Max - Min
            let L: CGFloat = (Max + Min) / 2.0
            var H: CGFloat = 0.0
            var S: CGFloat = 0.0
            if Delta != 0.0
            {
                if L < 0.5
                {
                    S = Max / (Max + Min)
                }
                else
                {
                    S = Max / (2.0 - Max - Min)
                }
                let DeltaR = (((Max - Red) / 6.0) + (Max / 2.0)) / Max
                let DeltaG = (((Max - Green) / 6.0) + (Max / 2.0)) / Max
                let DeltaB = (((Max - Blue) / 6.0) + (Max / 2.0)) / Max
                if Red == Max
                {
                    H = DeltaB - DeltaG
                }
                else
                if Green == Max
                {
                    H = (1.0 / 3.0) + (DeltaR - DeltaB)
                }
                else
                if Blue == Max
                {
                    H = (2.0 / 3.0) + (DeltaG - DeltaR)
                }
                if H < 0.0
                {
                    H = H + 1.0
                }
                if H > 1.0
                {
                    H = H - 1.0
                }
            }
            return (H, S, L)
        }
    }
    
    /// Returns the greatest channel magnitude.
    var GreatestMagnitude: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return max(Red, Green, Blue)
        }
    }
    
    /// Returns the least channel magnitude.
    var LeastMagnitude: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return min(Red, Green, Blue)
        }
    }
    
    /// Returns a brightened version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's brightness component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Brightened color.
    func Brighten(By Percent: CGFloat) -> NSColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = 1.0 + Percent
        Brightness = Brightness * Multiplier
        return NSColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns a darkened version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's brightness component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Darkened color.
    func Darken(By Percent: CGFloat) -> NSColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = Percent
        Brightness = Brightness * Multiplier
        return NSColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns a more saturated version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's saturation component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Increased saturation color.
    func Saturate(By Percent: CGFloat) -> NSColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = 1.0 + Percent
        Saturation = Saturation * Multiplier
        return NSColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns a desaturated version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's saturation component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Desaturated color.
    func Desaturate(By Percent: CGFloat) -> NSColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = Percent
        Saturation = Saturation * Multiplier
        return NSColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns the normalized red value.
    var r: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Red
        }
    }
    
    /// Returns the normalized green value.
    var g: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Green
        }
    }
    
    /// Returns the normalized blue value.
    var b: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Blue
        }
    }
    
    /// Returns the normalized alpha value.
    var a: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Alpha
        }
    }
    
    static func Random(MinRed: CGFloat = 0.5, MinGreen: CGFloat = 0.5, MinBlue: CGFloat = 0.5) -> NSColor
    {
        let Red = CGFloat.random(in: MinRed ... 1.0)
        let Green = CGFloat.random(in: MinGreen ... 1.0)
        let Blue = CGFloat.random(in: MinBlue ... 1.0)
        return NSColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    static func Random(MaxRed: CGFloat = 0.5, MaxGreen: CGFloat = 0.5, MaxBlue: CGFloat = 0.5) -> NSColor
    {
        let Red = CGFloat.random(in: 0.0 ... MaxRed)
        let Green = CGFloat.random(in: 0.0 ... MaxGreen)
        let Blue = CGFloat.random(in: 0.0 ... MaxBlue)
        return NSColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    static func Random() -> NSColor
    {
        let Red = CGFloat.random(in: 0.0 ... 1.0)
        let Green = CGFloat.random(in: 0.0 ... 1.0)
        let Blue = CGFloat.random(in: 0.0 ... 1.0)
        return NSColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    static func Random(RedLow: CGFloat = 0.2, RedHigh: CGFloat = 0.8, GreenLow: CGFloat = 0.2,
                       GreenHigh: CGFloat = 0.8, BlueLow: CGFloat = 0.2, BlueHigh: CGFloat = 0.8) -> NSColor
    {
        var ARedLow = RedLow
        var ARedHigh = RedHigh
        if ARedLow > ARedHigh
        {
            swap(&ARedLow, &ARedHigh)
        }
        var AGreenLow = GreenLow
        var AGreenHigh = GreenHigh
        if AGreenLow > AGreenHigh
        {
            swap(&AGreenLow, &AGreenHigh)
        }
        var ABlueLow = BlueLow
        var ABlueHigh = BlueHigh
        if ABlueLow > ABlueHigh
        {
            swap(&ABlueLow, &ABlueHigh)
        }
        let Red = CGFloat.random(in: ARedLow ... ARedHigh)
        let Green = CGFloat.random(in: AGreenLow ... AGreenHigh)
        let Blue = CGFloat.random(in: ABlueLow ... ABlueHigh)
        return NSColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    /// Compare the instance color with the passed color using a common colorspace.
    /// - Note: Both the instance color and the passed color are converted to the `sRGB`
    ///         colorspace.
    /// - Parameter Other: The other color to compare to the instance color.
    /// - Returns: True if the colors are the same in the common colorspace, false if not.
    func SameAs(_ Other: NSColor) -> Bool
    {
        let SelfColor = self.usingColorSpace(.sRGB)
        let OtherColor = Other.usingColorSpace(.sRGB)
        if SelfColor == OtherColor
        {
            return true
        }
        return false
    }
    
    // MARK: - Named colors.
    
    static var Maroon: NSColor
    {
        get
        {
            return NSColor(HexString: "#800000")!
        }
    }
    
    static var Gold: NSColor
    {
        get
        {
            return NSColor(HexString: "#ffd700")!
        }
    }
    
    static var DavysGray: NSColor
    {
        get
        {
            return NSColor(HexString: "#555555")!
        }
    }
    
    static var Jet: NSColor
    {
        get
        {
            return NSColor(HexString: "#343434")!
        }
    }
    
    static var GunMetal: NSColor
    {
        get
        {
            return NSColor(HexString: "#2a3439")!
        }
    }
    
    static var BlackGray: NSColor
    {
        get
        {
            return NSColor(HexString: "#2e3234")!
        }
    }
    
    static var BlackGrey: NSColor
    {
        get
        {
            return BlackGray
        }
    }
    
    static var LightSkyBlue: NSColor
    {
        get
        {
            return NSColor(HexString: "#87cefa")!
        }
    }
    
    static var PrussianBlue: NSColor
    {
        get
        {
            return NSColor(HexString: "#003171")!
        }
    }
    
    static var BerkeleyBlue: NSColor
    {
        get
        {
            return NSColor(HexString: "#003262")!
        }
    }
    
    static var Sapphire: NSColor
    {
        get
        {
            return NSColor(HexString: "#082567")!
        }
    }
    
    static var Independence: NSColor
    {
        get
        {
            return NSColor(HexString: "#4c516d")!
        }
    }
    
    static var DelftBlue: NSColor
    {
        get
        {
            return NSColor(HexString: "#1f305e")!
        }
    }
    
    /// Resene Space Cadet color.
    /// - Note: See [Resene Space Cadet](https://www.resene.co.nz/swatches/preview.php?chart=Resene%20Multi-finish%20range%20%282016%29&brand=Resene&name=Space%20Cadet)
    static var SpaceCadet: NSColor
    {
        get
        {
            return NSColor(HexString: "#1e2952")!
        }
    }
    
    static var Pistachio: NSColor
    {
        get
        {
            return NSColor(HexString: "#93c572")!
        }
    }
    
    static var Lime: NSColor
    {
        get
        {
            return NSColor(HexString: "#bfff00")!
        }
    }
    
    static var Midori: NSColor
    {
        get
        {
            return NSColor(HexString: "#2a603b")!
        }
    }
    
    static var Botan: NSColor
    {
        get
        {
            return NSColor(HexString: "#a4345d")!
        }
    }
    
    static var Shironeri: NSColor
    {
        get
        {
            return NSColor(HexString: "#ffddca")!
        }
    }
    
    static var Ajiiro: NSColor
    {
        get
        {
            return NSColor(HexString: "#ebf6f7")!
        }
    }
    
    static var ArtichokeGreen: NSColor
    {
        get
        {
            return NSColor(HexString: "#4b6f44")!
        }
    }
    
    static var TeaGreen: NSColor
    {
        get
        {
            return NSColor(HexString: "#d0f0c0")!
        }
    }
    
    static var PacificBlue: NSColor
    {
        get
        {
            return NSColor(HexString: "#009dc4")!
        }
    }
    
    static var UltraPink: NSColor
    {
        get
        {
            return NSColor(HexString: "#ff6fff")!
        }
    }
    
    static var Sunglow: NSColor
    {
        get
        {
            return NSColor(HexString: "#ffcc33")!
        }
    }
    
    static var Scarlet: NSColor
    {
        get
        {
            return NSColor(HexString: "#ff2400")!
        }
    }
    
    // MARK: - Color shifting
    
    /// Returns the number of seconds in a given time period.
    /// - Parameter Period: Length of a period whose number of seconds is returned.
    /// - Parameter In: The date used to determine the month to return the number of seconds.
    /// - Returns: Number of seconds in the specified time period.
    func SecondsIn(Period: ColorTimePeriods, In: Date) -> Int
    {
        switch Period
        {
            case .Minutes:
                return 60
                
            case .Hours:
                return 60 * 60
                
            case .Days:
                return 60 * 60 * 24
                
            case .Months:
                let Cal = Calendar.current
                let Interval = Cal.dateInterval(of: .month, for: In)
                let Days = Cal.dateComponents([.day], from: Interval!.start, to: Interval!.end).day!
                return Days * 60 * 60 * 24
        }
    }
    
    /// Given the current time, return the number of seconds in a given period of time that have elapsed.
    /// - Parameter OfPeriod: The color cycle period length.
    /// - From: The current time used to determine how many seconds have elapsed.
    /// - Returns: Number of seconds away from the integral start of the specified period of time.
    func SecondsFromStart(OfPeriod: ColorTimePeriods, From: Date) -> Int
    {
        let Cal = Calendar.current
        switch OfPeriod
        {
            case .Minutes:
                let Seconds = Cal.component(.second, from: From)
                return Seconds
                
            case .Hours:
                let Seconds = Cal.component(.second, from: From)
                let Minutes = Cal.component(.minute, from: From)
                return (Minutes * 60) + Seconds
                
            case .Days:
                let Seconds = Cal.component(.second, from: From)
                let Minutes = Cal.component(.minute, from: From)
                let Hours = Cal.component(.hour, from: From)
                return (Hours * 60 * 60) + (Minutes * 60) + Seconds
                
            case .Months:
                let Seconds = Cal.component(.second, from: From)
                let Minutes = Cal.component(.minute, from: From)
                let Hours = Cal.component(.hour, from: From)
                let Days = Cal.component(.day, from: From)
                return ((Days - 1) * 24 * 60 * 60) + (Hours * 60 * 60) + (Minutes * 60) + Seconds
        }
    }
    
    /// Returns the current percent of the way through the specified time period.
    ///
    /// - Parameters:
    ///   - Period: Determines the period.
    ///   - Now: Current time the percent is desired for.
    /// - Returns: Percent of the way through the period.
    func Percent(Period: ColorTimePeriods, Now: Date) -> Double
    {
        let TotalTime = SecondsIn(Period: Period, In: Now)
        let FromStart = SecondsFromStart(OfPeriod: Period, From: Now)
        let TimePercent = Double(FromStart) / Double(TotalTime)
        return TimePercent
    }
    
    /// Move the instance color to a new color.
    /// - Warning: This function will crash on grayscale colors. The caller should call `InRGB` before calling
    ///         this function.
    /// - Parameter To: The current time over the reference length of time - determines the new color.
    /// - Parameter Period: The length of the color cycle period.
    /// - Parameter Forward: Determines the direction of the motion of the color.
    /// - Returns: Updated color.
    func Move(To: Date, Period: ColorTimePeriods, Forward: Bool, FinalHue: inout CGFloat) -> NSColor
    {
        let (Hue, Sat, Bri) = HSB
        let PeriodPercent = Percent(Period: Period, Now: To)
        var WorkingHue = (Hue * 360.0) + CGFloat(PeriodPercent * 360.0)
        WorkingHue = fmod(WorkingHue, 360.0)
        WorkingHue = WorkingHue / 360.0
        if !Forward
        {
            WorkingHue = 1.0 - WorkingHue
        }
        FinalHue = WorkingHue
        let Final = NSColor(calibratedHue: WorkingHue, saturation: Sat, brightness: Bri, alpha: 1.0)
        return Final
    }
    
    /// Blend two colors together.
    /// - Parameter Color1: First color.
    /// - Parameter Color2: Second color.
    /// - Parameter IncludeAlpha: If true, alpha is blended as well. If false, `1.0` is used for alpha.
    /// - Parameter Percent: Spatial distance expressed as a normal for how far apart the point is between
    ///                      the two colors.
    /// - Returns: Blended color.
    public static func BlendColors(Color1: NSColor, Color2: NSColor, IncludeAlpha: Bool = false,
                                   Percent: CGFloat) -> NSColor
    {
        let R1 = Color1.r
        let R2 = Color2.r
        let G1 = Color1.g
        let G2 = Color2.g
        let B1 = Color1.b
        let B2 = Color2.b
        let A1 = Color1.a
        let A2 = Color2.a
        
        let RSum = (R1 * (1.0 - Percent)) + (R2 * Percent)
        let GSum = (G1 * (1.0 - Percent)) + (G2 * Percent)
        let BSum = (B1 * (1.0 - Percent)) + (B2 * Percent)
        var ASum: CGFloat = 0.0
        if IncludeAlpha
        {
            ASum = (A1 * (1.0 - Percent)) + (A2 * Percent)
        }
        else
        {
            ASum = 1.09
        }
        
        return NSColor(calibratedRed: RSum, green: GSum, blue: BSum, alpha: ASum)
    }
    
    /// Returns the opposite color of the instance color, where "opposite" is defined in terms of hue (technically,
    /// "opposite" means 180Â° away form the original color. Additionally, saturation is "inverted".
    /// - Returns: High-constrast color based on the instance color.
    public func OppositeColor() -> NSColor
    {
        let (H, S, B) = self.HSB
        var NewHue = 360.0 * H
        NewHue = NewHue + 180.0
        NewHue = fmod(NewHue, 360.0) / 360.0
        var NewSat = 100.0 * S
        NewSat = NewSat + 50.0
        NewSat = fmod(NewSat, 100.0) / 100.0
        let Final = NSColor(calibratedHue: NewHue, saturation: NewSat, brightness: B, alpha: 1.0)
        return Final
    }
}

enum ColorTimePeriods
{
    case Minutes
    case Hours
    case Days
    case Months
}

